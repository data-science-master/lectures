---
title: "SQL"
author: "David Gerard"
date: "`r Sys.Date()`"
output:  
  html_document:
    toc: true
    toc_depth: 4
urlcolor: "blue"
---

```{r createData, eval = FALSE, echo = FALSE}
## Code to write flights.duckdb
library(DBI)
library(duckdb)
library(nycflights13)
con <- dbConnect(duckdb(dbdir = "flights.duckdb", read_only = FALSE))
dbWriteTable(conn = con, name = "airlines", value = airlines)
dbWriteTable(conn = con, name = "airports", value = airports)
dbWriteTable(conn = con, name = "flights", value = flights)
dbWriteTable(conn = con, name = "planes", value = planes)
dbWriteTable(conn = con, name = "weather", value = weather)
dbDisconnect(con, shutdown = TRUE)
```


```{r setup, include=FALSE}
set.seed(1)
knitr::opts_chunk$set(echo       = TRUE, 
                      fig.height = 3, 
                      fig.width  = 6,
                      fig.align  = "center")
ggplot2::theme_set(ggplot2::theme_bw())
```

# Learning Objectives

- Learn some SQL
- Interface SQL with R through the `{DBI}` and `{duckdb}` packages.
    - Introduction to DBI: <https://solutions.posit.co/connections/db/r-packages/dbi/>
    - DuckDB SQL Introduction: <https://duckdb.org/docs/sql/introduction>
    - DuckDB R API: <https://duckdb.org/docs/api/r.html>
- Write SQL code using the tidyverse and the `{dbplyr}` package.
    - `{dbplyr}` and SQL: <https://dbplyr.tidyverse.org/articles/sql.html>
    - R for Data Science Database Chapter: <https://r4ds.hadley.nz/databases.html>

# SQL Introduction and SetUp

- SQL is pronounced either "ess-kew-ell" or "sequel" (either is fine).

- SQL is a programming language which basically allows you to do everything that dplyr does (filters, selects, joins, etc...). It is the industry standard for interacting with a relational database.

- There are a lots of [database management systems](https://en.wikipedia.org/wiki/Database#Database_management_system) (DBMS) that use SQL to connect to their databases.

- In this lecture, we will only consider [DuckDB](https://duckdb.org/) since it has no external dependencies and is pretty easy to install. Just do this in R:

    <mark style="background-color: lightblue">R</mark>
    
    ``` r
    install.packages("duckdb")
    ```

- The most popular DBMS is probably [SQLite](https://www.sqlite.org/index.html). Another popular one is [MySQL](https://www.mysql.com/).

# DuckDB

- DuckDB is a specific SQL backend. The R package that is used to connect to any SQL backend is `{DBI}`, and so we will load that one too.

    <mark style="background-color: lightblue">R</mark>
    ```{r, message = FALSE}
    library(DBI)
    library(duckdb)
    ```
    
- We will compare to the tidyverse:

    <mark style="background-color: lightblue">R</mark>
    ```{r, message = FALSE}
    library(nycflights13)
    library(tidyverse)
    ```

- Let's download a duck database that I created. Put this in a location you can get to: <https://data-science-master.github.io/lectures/data/flights.duckdb>

- Use `duckdb()` and `DBI::dbConnect()` to create a connection to "flights.duckdb".

    <mark style="background-color: lightblue">R</mark>
    ```{r}
    con <- dbConnect(duckdb(dbdir = "../data/flights.duckdb", read_only = TRUE))
    ```

- A basic SQL code chunk looks like this (put SQL code between the chunks):

    ```{r, echo = FALSE, comment = ""}
    codechunk <- "```{sql, connection=con}\n\n```"
    writeLines(codechunk)
    ```

# Basic SQL

## General

- Case does not matter (i.e. `select` is the same as `SELECT` is the same as `SeLeCt`), but it is standard to have all statements be in fuller UPPERCASE (i.e. `SELECT`).

- The statements below **must** be in the following order: `SELECT`, `FROM`, `WHERE`, `GROUP BY`, `ORDER BY`.

- Character values must be in single quotes.

- You can use invalid variable names by putting them in double quotes.

## Showing Tables

- The `SHOW TABLES` command can be used to get a list of all of the tables

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SHOW TABLES
    ```

- The `DESCRIBE` command can be used to show tables and the variables.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    DESCRIBE
    ```

## Select Specific Columns

- To get the columns from a data frame, use the `SELECT` command.

- The syntax is like this

    <mark style="background-color: #e24e2f">SQL</mark>
    
    ``` sql
    SELECT <column1>, <column2>, <column3> FROM <mytable>
    ```
    
- Let's use this to get the `tailnum`, `year`, and `model` variables from the `planes` table.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT tailnum, year, model FROM planes
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    planes %>%
      select(tailnum, year, model)
    ```

- You select every column by using `*`:

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT * FROM planes
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    planes
    ```

- There is no equivalent for excluding columns (like `dplyr::select(-year)`). You just select the ones you want.

## Filter rows

- You use the `WHERE` command in SQL to filter by rows.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, distance, origin, dest FROM flights
        WHERE distance < 50
    ```
    
- R equivalent:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, distance, origin, dest) %>%
      filter(distance < 50)
    ```

    
- To test for equality, you just use one equals sign.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, month FROM flights
        WHERE month = 12
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, month) %>%
      filter(month == 12)
    ```


- For characters you **must use single quotes**, not double.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, origin FROM flights
        WHERE origin = 'JFK'
    ```
    
- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, origin) %>%
      filter(origin == "JFK")
    ```


- You can select multiple criteria using the `AND` command

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, origin, dest FROM flights
        WHERE origin = 'JFK' AND dest = 'CMH'
    ```

- R equivalent:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, origin, dest) %>%
      filter(origin == "JFK", dest == "CMH")
    ```


- You can use the `OR` logical operator too. Just put parentheses around your desired order of operations.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, origin, dest FROM flights
        WHERE (origin = 'JFK' OR origin = 'LGA') AND dest = 'CMH'
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, origin, dest) %>%
      filter(origin == "JFK" | origin == "LGA", dest == "CMH")
    ```

- Missing data is `NULL` in SQL (instead of `NA`). We can remove them by the special command:

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, dep_delay FROM flights
        WHERE dep_delay IS NOT NULL
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, dep_delay) %>%
      filter(!is.na(dep_delay))
    ```

- Just use `IS` if you want the missing data observations

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, dep_delay FROM flights
        WHERE dep_delay IS NULL
    ```

## Arranging Rows

- Use `ORDER BY` to rearrange the rows (let's remove missing values so we can see the ordering)

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    select flight, dep_delay FROM flights
        WHERE dep_delay IS NOT NULL
        ORDER BY dep_delay
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, dep_delay) %>%
      filter(!is.na(dep_delay)) %>%
      arrange(dep_delay)
    ```
    
- Use `DESC` after the variable to arrange in descending order

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, dep_delay FROM flights
        WHERE dep_delay IS NOT NULL
        ORDER BY dep_delay DESC
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, dep_delay) %>%
      filter(!is.na(dep_delay)) %>%
      arrange(desc(dep_delay))
    ```

- You break ties by adding more variables in the `ORDER BY` statement

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, origin, dep_delay FROM flights
        WHERE dep_delay IS NOT NULL
        ORDER BY origin desc, dep_delay
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, origin, dep_delay) %>%
      filter(!is.na(dep_delay)) %>%
      arrange(desc(origin), dep_delay)
    ```

## Mutate

- In SQL, you mutate variables while you SELECT. You use `AS` to specify what the new variable is called (choosing a variable name is called "aliasing" in SQL).

    <mark style="background-color: #e24e2f">SQL</mark>
    
    ``` sql
    SELECT <expression> AS <myvariable> FROM <mytable>
    ```

- Let's calculate average speed from the `flights` table. We'll also keep the flight number, distance, and air time variables.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, distance / air_time AS speed, distance, air_time FROM flights
    ```

- R equivalent:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, distance, air_time) %>%
      mutate(speed = distance / air_time)
    ```
    
- Various transformation functions also exist:
    - `LN()`: Natural log transformation.
    - `EXP()`: Exponentiation.
    - `SQRT()`: Square root.
    - `POW()`: Power transformation. 
        - `POW(2.0, x)` would be $2^x$
        - `POW(x, 2.0)` would be $x^2$.

## Group Summaries

- SQL has a few summary functions (SQL calls these "[Aggregates](https://duckdb.org/docs/sql/aggregates)")
    - `COUNT()`: Count the number of rows.
    - `AVG()`: Calculate average.
    - `MEDIAN()`: Median.
    - `SUM()`: Summation.
    - `MIN()`: Minimum.
    - `MAX()`: Maximum.
    - `STDDEV()`: Standard deviation.
    - `VARIANCE()`: Variance
    
- By default, all missing data are ignored (like setting `na.rm = TRUE`).
    
- These are calculated in a `SELECT` command

- Let's calculate the average departue delay

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT AVG(dep_delay) AS dep_delay FROM flights
    ```

- R equivalent:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      summarize(dep_delay = mean(dep_delay, na.rm = TRUE))
    ```
    
- Use the `GROUP BY` command to calculate group summaries.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT origin, AVG(dep_delay)
        FROM flights
        GROUP BY origin
    ```

- R equivalent

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(origin, dep_delay) %>%
      group_by(origin) %>%
      summarize(dep_delay = mean(dep_delay, na.rm = TRUE))
    ```

## Recoding

- Use the following `CASE`-`WHEN` syntax to recode values

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, origin, CASE
              WHEN (origin = 'JFK') THEN 'John F. Kennedy'
              WHEN (origin = 'LGA') THEN 'LaGaurdia'
              WHEN (origin = 'EWR') THEN 'Newark Liberty'
              END AS olong
        FROM flights
    ```

- R equivalent:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, origin) %>%
      mutate(olong = case_when(
        origin == "JFK" ~ "John F. Kennedy",
        origin == "LGA" ~ "LaGuardia",
        origin == "EWR" ~ "Newark Liberty")
      )
    
    ## or
    flights %>%
      select(flight, origin) %>%
      mutate(olong = recode(
        origin,
        "JFK" = "John F. Kennedy",
        "LGA" = "LaGuardia",
        "EWR" = "Newark Liberty")
      )
    ```
    
- You can also use `CASE`-`WHEN` to recode based on other logical operations

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=con}
    SELECT flight, air_time, CASE
              WHEN (air_time > 2500) THEN 'Long'
              WHEN (air_time <= 2500) THEN 'Short'
              END AS qual_dist
        FROM flights
    ```
    
- R equivalent:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    flights %>%
      select(flight, air_time) %>%
      mutate(qual_dist = case_when(
        air_time > 2500 ~ "Long",
        air_time <= 2500 ~ "Short")
      )
    
    ## or
    flights %>%
      select(flight, air_time) %>%
      mutate(qual_dist = if_else(air_time > 2500, "Long", "Short"))
    ```

## Creating some Tables

- Let's create a new, temporary, connection that we can put some example tables in.

    <mark style="background-color: lightblue">R</mark>
    ```{r}
    tmpcon <- dbConnect(duckdb())
    ```

- For the gathering, spreading, separating, and uniting sections, I will use the `tmpcon` connection.

- Let's create the tables we will need. Note that I am putting a semicolon "`;`" after each SQL call in the same code chunk.

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=tmpcon}
    CREATE TABLE table4a (
        country VARCHAR,
        "1999"   INTEGER,
        "2000"   INTEGER
    );
    
    INSERT INTO table4a (country, "1999", "2000") 
        VALUES
            ('Afghanistan',    745,   2666),
            ('Brazil'     ,  37737,  80488),
            ('China'      , 212258, 213766);
            
    CREATE TABLE table2 (
        country VARCHAR,
        year    INTEGER,
        "type"  VARCHAR,
        "count" INTEGER
    );
    
    INSERT INTO table2 (country, year, "type", "count")
        VALUES
            ('Afghanistan',  1999, 'cases'     ,        745),
            ('Afghanistan',  1999, 'population',   19987071),
            ('Afghanistan',  2000, 'cases'     ,       2666),
            ('Afghanistan',  2000, 'population',   20595360),
            ('Brazil'     ,  1999, 'cases'     ,      37737),
            ('Brazil'     ,  1999, 'population',  172006362),
            ('Brazil'     ,  2000, 'cases'     ,      80488),
            ('Brazil'     ,  2000, 'population',  174504898),
            ('China'      ,  1999, 'cases'     ,     212258),
            ('China'      ,  1999, 'population', 1272915272),
            ('China'      ,  2000, 'cases'     ,     213766),
            ('China'      ,  2000, 'population', 1280428583);
    ```
    
- Note that I used double quotes to create variables with reserved words.

- Here they are:

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=tmpcon}
    DESCRIBE
    ```


## Gathering

- SQL folk call "gathering" as "unpivoting", so that is what you need to Google.

- `table4a` needs to be gathered:

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=tmpcon}
    SELECT * FROM table4a
    ```


- The way to do this is to do an row-bind from two constructed tables.

- Here is the first table
    ```{sql, connection=tmpcon}
    SELECT country, '1999' AS year, "1999" AS count
    FROM table4a
    ```
    
    - Notice that `'1999' AS year` creates a new column called `year` that has just the value `1999`.

    - Notice that `"1999" AS count` just renames the `"1999"` column to be the `"count"` column

- Here is the second table
    ```{sql, connection=tmpcon}
    SELECT country, '2000' AS year, "2000" AS count
    FROM table4a
    ```
    
- Use `UNION ALL` to bind the rows
    ```{sql, connection=tmpcon}
    (
      SELECT country, '1999' AS year, "1999" AS count
      FROM table4a
    )
    UNION ALL
    (
      SELECT country, '2000' AS year, "2000" AS count
      FROM table4a
    )
    ```

- R way:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    data("table4a", package = "tidyr")
    table4a %>%
      gather(`1999`, `2000`, key = "year", value = "count")
    
    ## or
    table4a %>%
      pivot_longer(cols = c("1999", "2000"), names_to = "year", values_to = "count")
    ```

## Spreading

- "country" and "year" are the ID columns, "type" is the name column, and "count" is the values column.
    
    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=tmpcon}
    SELECT * FROM table2
    ```

- Spreading (or "pivoting") is a pain in SQL:

    <mark style="background-color: #e24e2f">SQL</mark>
    ```{sql, connection=tmpcon}
    SELECT "country", "year",
           MAX("count") FILTER (WHERE "type" = 'cases') AS cases,
           MAX("count") FILTER (WHERE "type" = 'population') AS population
        FROM table2
        GROUP BY "country", "year"
    ```

- The idea is that we calculate separate summary statistics for each combination of "country" and "year". 
    - One where the observations are 'cases' and one where the observations are 'population'.
    - This summary statistic is of a single value --- itself.
    - I chose `MAX`, but it could have been `MIN` or even `SUM` or `AVG`. This is because they all return the same value if you give it only one observation.

- R way:

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    data("table2", package = "tidyr")
    table2 %>%
      spread(key = type, value = count)
    
    ## Or
    table2 %>%
      pivot_wider(names_from = "type", values_from = "count", id_cols = c("country", "year"))
    ```

- Let's disconnect: 

    <mark style="background-color: lightblue">R</mark>
    ```{r, eval = FALSE}
    dbDisconnect(tmpcon, shutdown = TRUE)
    ```

## Separating

## Uniting

## Joining

# Use R to generate SQL with `{dbplyr}`

- `{dbplyr}` allows you to use `{dplyr}` code on a SQL backend.

- It will even generate SQL code for you, so you can use it as a way to learn SQL.

- Let's load it in:

    <mark style="background-color: lightblue">R</mark>
    ```{r, message=FALSE}
    library(dbplyr)
    ```

- You retrieve a table from a SQL database using `tbl()`

    <mark style="background-color: lightblue">R</mark>
    ```{r}
    flights2 <- tbl(src = con, "flights")
    ```

- Now you can use your tidyverse code on the flights table

    <mark style="background-color: lightblue">R</mark>
    ```{r}
    flights2 %>%
      select(flight, origin, dest, dep_delay) %>%
      filter(origin == "JFK", dest == "CMH") %>%
      summarize(dep_delay = mean(dep_delay, na.rm = TRUE))
    ```
    
- You execute the query by using `collect()` at the end.

    <mark style="background-color: lightblue">R</mark>
    ```{r}
    flights2 %>%
      select(flight, origin, dest, dep_delay) %>%
      filter(origin == "JFK", dest == "CMH") %>%
      summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
      collect()
    ```

- To see the SQL code that was generated, use `show_query()` at the end (this is a good way to learn SQL).

    <mark style="background-color: lightblue">R</mark>
    ```{r}
    flights2 %>%
      select(flight, origin, dest, dep_delay) %>%
      filter(origin == "JFK", dest == "CMH") %>%
      summarize(dep_delay = mean(dep_delay, na.rm = TRUE)) %>%
      show_query()
    ```

# Closing the Connection

- After you are done with SQL, you should close down your connection:

    <mark style="background-color: lightblue">R</mark>
    ```{r}
    DBI::dbDisconnect(con, shutdown = TRUE)
    ```
    
<!-- # Use SQL in R with `{DBI}` -->

<!-- - It's best to have SQL written in a separate file (that ends in ".sql"). -->

<!-- - If you want to load the results of a SQL query in R, saved in "query.sql", do -->
<!--     ```{r, eval = FALSE} -->
<!--     mydf <- DBI::dbGetQuery(conn, statement = read_file(here("query.sql"))) -->
<!--     ``` -->
